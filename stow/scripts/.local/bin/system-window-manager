#!/bin/bash
# Scalable window manager for exclusive floating windows
# Listens to Hyprland events and manages window exclusions based on config

CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/window-manager/config.json"
LOG_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/window-manager.log"
SOCKET_PATH="/run/user/$(id -u)/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock"

# Ensure directories exist
mkdir -p "$(dirname "$CONFIG_FILE")"
mkdir -p "$(dirname "$LOG_FILE")"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"
    [[ "${VERBOSE:-0}" == "1" ]] && echo "$*"
}

# Check if Hyprland is running
check_hyprland() {
    if [[ -z "$HYPRLAND_INSTANCE_SIGNATURE" ]]; then
        log "ERROR: Not running in Hyprland session"
        exit 1
    fi
    
    if [[ ! -S "$SOCKET_PATH" ]]; then
        log "ERROR: Hyprland socket not found at $SOCKET_PATH"
        exit 1
    fi
}

# Create default config if it doesn't exist
create_default_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log "Creating default configuration at $CONFIG_FILE"
        cat > "$CONFIG_FILE" << 'EOF'
{
  "exclusive_groups": {
    "overlays": {
      "description": "Floating overlay panels that should be mutually exclusive",
      "windows": [
        {
          "class": "org.wezfurlong.wezterm",
          "title": "VolumePanel",
          "close_method": "hyprctl dispatch closewindow address:{address}"
        },
        {
          "class": "com.github.Aylur.ags",
          "title": "VolumePanel",
          "close_method": "hyprctl dispatch closewindow address:{address}"
        },
        {
          "class": "SwayNotificationCenter",
          "title": "",
          "close_method": "swaync-client -cp"
        }
      ]
    },
    "launchers": {
      "description": "Application launchers",
      "windows": [
        {
          "class": "walker",
          "title": "",
          "close_method": "pkill walker"
        },
        {
          "class": "rofi",
          "title": "",
          "close_method": "pkill rofi"
        }
      ]
    }
  },
  "settings": {
    "debug": false,
    "delay_ms": 50
  }
}
EOF
    fi
}

# Parse JSON config (using jq if available, fallback to basic parsing)
parse_config() {
    if command -v jq >/dev/null 2>&1; then
        jq -r "$1" "$CONFIG_FILE" 2>/dev/null
    else
        # Basic fallback - not as robust but works for simple cases
        grep -o "\"$1\"[^,}]*" "$CONFIG_FILE" | cut -d'"' -f4
    fi
}

# Get all exclusive groups
get_groups() {
    if command -v jq >/dev/null 2>&1; then
        jq -r '.exclusive_groups | keys[]' "$CONFIG_FILE" 2>/dev/null
    else
        log "WARNING: jq not found, limited functionality"
        return 1
    fi
}

# Check if window matches any pattern in a group
window_matches_group() {
    local window_class="$1"
    local window_title="$2"
    local group="$3"
    
    if command -v jq >/dev/null 2>&1; then
        # Use jq to check if window matches any pattern in the group
        jq -r --arg class "$window_class" --arg title "$window_title" --arg group "$group" '
            .exclusive_groups[$group].windows[] | 
            select(
                (.class == $class or .class == "") and 
                (.title == $title or .title == "" or ($title | test(.title)))
            ) | 
            .close_method
        ' "$CONFIG_FILE" 2>/dev/null | head -1
    fi
}

# Check if a window class should be excluded from management
is_excluded_from_management() {
    local window_class="$1"
    
    if command -v jq >/dev/null 2>&1; then
        # Check if class matches any exclusion pattern
        jq -e --arg class "$window_class" '
            .exclude_from_management.patterns[] | test($class)
        ' "$CONFIG_FILE" >/dev/null 2>&1
    else
        return 1
    fi
}

# Run special close commands when overlay applications open
run_special_close_commands() {
    if command -v jq >/dev/null 2>&1; then
        jq -r '.special_close_commands.on_overlay_open[]?' "$CONFIG_FILE" 2>/dev/null | while IFS= read -r command; do
            [[ -n "$command" ]] && {
                log "Running special close command: $command"
                eval "$command" &
            }
        done
    fi
}

# Get windows to close when a new window opens
get_conflicting_windows() {
    local new_class="$1"
    local new_title="$2"
    local new_address="$3"
    
    while IFS= read -r group; do
        # Check if new window belongs to this group
        local close_method
        close_method=$(window_matches_group "$new_class" "$new_title" "$group")
        
        if [[ -n "$close_method" ]]; then
            log "New window ($new_class: $new_title) matches group: $group"
            
            # Run special close commands
            run_special_close_commands
            
            # Find conflicting regular windows
            hyprctl clients -j 2>/dev/null | jq -r --arg group "$group" --arg new_addr "$new_address" '
                .[] | select(.address != $new_addr) | 
                "\(.class)|\(.title)|\(.address)"
            ' 2>/dev/null | while IFS='|' read -r class title address; do
                local existing_close_method
                existing_close_method=$(window_matches_group "$class" "$title" "$group")
                
                if [[ -n "$existing_close_method" ]]; then
                    log "Closing conflicting window: $class ($title) at $address"
                    
                    local final_command
                    final_command=$(echo "$existing_close_method" | sed "s/{address}/$address/g")
                    
                    eval "$final_command" &
                fi
            done
            
            # Find conflicting layer-shell surfaces
            hyprctl layers -j 2>/dev/null | jq -r --arg group "$group" --arg new_addr "$new_address" '
                .[] | .levels | .[] | .[] | select(.address != $new_addr) |
                "\(.namespace)|\(.namespace)|\(.address)"
            ' 2>/dev/null | while IFS='|' read -r class title address; do
                local existing_close_method
                existing_close_method=$(window_matches_group "$class" "$title" "$group")
                
                if [[ -n "$existing_close_method" ]]; then
                    log "Closing conflicting layer surface: $class ($title) at $address"
                    
                    local final_command
                    final_command=$(echo "$existing_close_method" | sed "s/{address}/$address/g")
                    
                    eval "$final_command" &
                fi
            done
        fi
    done < <(get_groups)
}

# Process Hyprland events
process_event() {
    local event_line="$1"
    
    # Parse window open events: "openwindow>>ADDRESS,WORKSPACENAME,WINDOWCLASS,WINDOWTITLE"
    if [[ "$event_line" =~ ^openwindow\>\>([^,]*),([^,]*),([^,]*),(.*)$ ]]; then
        local address="${BASH_REMATCH[1]}"
        local workspace="${BASH_REMATCH[2]}"
        local class="${BASH_REMATCH[3]}"
        local title="${BASH_REMATCH[4]}"
        
        log "Window opened: $class ($title) at $address"
        
        # Small delay to ensure window is fully initialized
        local delay_ms
        delay_ms=$(parse_config '.settings.delay_ms // 50')
        sleep "0.$(printf "%03d" "$delay_ms")"
        
        get_conflicting_windows "$class" "$title" "$address"
    fi
}

# Main event loop using polling (fallback method)
start_monitoring() {
    log "Starting window manager monitoring..."
    log "Config file: $CONFIG_FILE"
    log "Socket: $SOCKET_PATH"
    
    # Force polling method for now (socket events not working in this Hyprland version)
    log "Using polling method for event monitoring"
    start_polling_monitoring
}

# Fallback polling method
start_polling_monitoring() {
    local last_windows=""
    local last_layers=""
    local current_windows=""
    local current_layers=""
    
    while true; do
        # Monitor regular windows
        current_windows=$(hyprctl clients -j 2>/dev/null | jq -r '.[] | "\(.class)|\(.title)|\(.address)"' 2>/dev/null | sort)
        
        # Monitor layer-shell surfaces (overlays, notifications, etc.)
        current_layers=$(hyprctl layers -j 2>/dev/null | jq -r '
            .[] | .levels | .[] | .[] | 
            "\(.namespace)|\(.namespace)|\(.address)"
        ' 2>/dev/null | sort)
        
        # Check for new regular windows
        if [[ "$current_windows" != "$last_windows" ]]; then
            while IFS='|' read -r class title address; do
                [[ -z "$address" ]] && continue
                
                if ! echo "$last_windows" | grep -q "$address"; then
                    log "New window detected: $class ($title) at $address"
                    
                    local delay_ms
                    delay_ms=$(parse_config '.settings.delay_ms // 50')
                    sleep "0.$(printf "%03d" "$delay_ms")"
                    
                    get_conflicting_windows "$class" "$title" "$address"
                fi
            done <<< "$current_windows"
            
            last_windows="$current_windows"
        fi
        
        # Check for new layer-shell surfaces
        if [[ "$current_layers" != "$last_layers" ]]; then
            while IFS='|' read -r class title address; do
                [[ -z "$address" ]] && continue
                
                if ! echo "$last_layers" | grep -q "$address"; then
                    # Check if this layer surface should be excluded from management
                    if ! is_excluded_from_management "$class"; then
                        log "New layer surface detected: $class ($title) at $address"
                        
                        local delay_ms
                        delay_ms=$(parse_config '.settings.delay_ms // 50')
                        sleep "0.$(printf "%03d" "$delay_ms")"
                        
                        get_conflicting_windows "$class" "$title" "$address"
                    else
                        log "Ignoring persistent layer surface: $class at $address"
                    fi
                fi
            done <<< "$current_layers"
            
            last_layers="$current_layers"
        fi
        
        sleep 0.2  # Poll every 200ms for faster overlay detection
    done
}

# Show help
show_help() {
    cat << EOF
system-window-manager - Scalable exclusive window manager for Hyprland

USAGE:
    system-window-manager [COMMAND] [OPTIONS]

COMMANDS:
    start           Start monitoring (default)
    config          Open config file in editor
    test            Test configuration parsing
    log             Show recent log entries
    
OPTIONS:
    -v, --verbose   Enable verbose output
    -h, --help      Show this help

CONFIGURATION:
    Config file: $CONFIG_FILE
    
EXAMPLES:
    system-window-manager start -v
    system-window-manager config
    system-window-manager test

EOF
}

# Test configuration
test_config() {
    echo "Testing configuration..."
    echo "Config file: $CONFIG_FILE"
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "❌ Config file not found"
        return 1
    fi
    
    if command -v jq >/dev/null 2>&1; then
        if jq empty "$CONFIG_FILE" 2>/dev/null; then
            echo "✅ Config file is valid JSON"
            echo
            echo "Exclusive groups:"
            jq -r '.exclusive_groups | to_entries[] | "  \(.key): \(.value.description)"' "$CONFIG_FILE"
        else
            echo "❌ Config file contains invalid JSON"
            return 1
        fi
    else
        echo "⚠️  jq not installed - install for full functionality"
        echo "   sudo pacman -S jq"
    fi
}

# Parse command line arguments
case "${1:-start}" in
    "start")
        [[ "$2" == "-v" || "$2" == "--verbose" ]] && VERBOSE=1
        check_hyprland
        create_default_config
        start_monitoring
        ;;
    "config")
        create_default_config
        ${EDITOR:-nano} "$CONFIG_FILE"
        ;;
    "test")
        create_default_config
        test_config
        ;;
    "log")
        if [[ -f "$LOG_FILE" ]]; then
            tail -n 20 "$LOG_FILE"
        else
            echo "No log file found"
        fi
        ;;
    "-h"|"--help"|"help")
        show_help
        ;;
    *)
        echo "Unknown command: $1"
        show_help
        exit 1
        ;;
esac