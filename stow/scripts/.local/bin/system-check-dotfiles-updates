#!/bin/bash
# Check for dotfiles repository updates
# Compares local HEAD with remote origin/main and writes state file

set -euo pipefail

# Configuration
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/dotfiles}"
STATE_DIR="$HOME/.local/state/dotfiles"
STATE_FILE="$STATE_DIR/updates.state"
SILENT_MODE=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --silent)
            SILENT_MODE=true
            shift
            ;;
        --help|-h)
            echo "Usage: system-check-dotfiles-updates [--silent]"
            echo ""
            echo "Checks for dotfiles repository updates by comparing local HEAD with origin/main."
            echo "Writes state to $STATE_FILE"
            echo ""
            echo "Options:"
            echo "  --silent    Skip notifications (for manual checks)"
            echo ""
            echo "Exit codes:"
            echo "  0 - No updates available"
            echo "  1 - Updates available"
            echo "  2 - Error occurred"
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 2
            ;;
    esac
done

# Ensure state directory exists
mkdir -p "$STATE_DIR"

# Change to dotfiles directory
if [[ ! -d "$DOTFILES_DIR/.git" ]]; then
    echo "Error: $DOTFILES_DIR is not a git repository" >&2
    exit 2
fi

cd "$DOTFILES_DIR" || exit 2

# Read previous state
PREV_UPDATES_AVAILABLE="false"
if [[ -f "$STATE_FILE" ]]; then
    source "$STATE_FILE" 2>/dev/null || true
    PREV_UPDATES_AVAILABLE="${UPDATES_AVAILABLE:-false}"
fi

# Fetch remote changes (quietly)
if ! git fetch origin main --quiet 2>/dev/null; then
    echo "Warning: Failed to fetch from remote" >&2
    # Write error state but don't fail completely
    cat > "$STATE_FILE" <<EOF
UPDATES_AVAILABLE=error
COMMIT_COUNT=0
LAST_CHECK=$(date +%s)
ERROR_MESSAGE="Failed to fetch from remote"
EOF
    exit 2
fi

# Get commit SHAs
LOCAL_COMMIT=$(git rev-parse HEAD 2>/dev/null)
REMOTE_COMMIT=$(git rev-parse origin/main 2>/dev/null)

# Count commits behind (updates to pull)
COMMIT_COUNT=$(git rev-list HEAD..origin/main --count 2>/dev/null || echo 0)

# Compare commits
if [[ "$LOCAL_COMMIT" == "$REMOTE_COMMIT" ]] || [[ "$COMMIT_COUNT" -eq 0 ]]; then
    # No updates (either same commit or we're ahead)
    cat > "$STATE_FILE" <<EOF
UPDATES_AVAILABLE=false
COMMIT_COUNT=0
LAST_CHECK=$(date +%s)
LOCAL_COMMIT=$LOCAL_COMMIT
REMOTE_COMMIT=$REMOTE_COMMIT
EOF
    exit 0
else
    # Updates available
    
    # Write state
    cat > "$STATE_FILE" <<EOF
UPDATES_AVAILABLE=true
COMMIT_COUNT=$COMMIT_COUNT
LAST_CHECK=$(date +%s)
LOCAL_COMMIT=$LOCAL_COMMIT
REMOTE_COMMIT=$REMOTE_COMMIT
EOF

    # Send notification if state changed (and not in silent mode)
    if [[ "$SILENT_MODE" == "false" ]] && [[ "$PREV_UPDATES_AVAILABLE" != "true" ]]; then
        # Get latest commit message for notification
        LATEST_COMMIT_MSG=$(git log origin/main -1 --pretty=format:"%s" 2>/dev/null || echo "")
        
        # Send mako notification with actions
        notify-send \
            --app-name="Dotfiles" \
            --icon="system-software-update" \
            --urgency=low \
            --expire-time=15000 \
            --action="update=Update Now" \
            --action="view=View Details" \
            "Dotfiles Updates Available" \
            "$COMMIT_COUNT new commit(s) on main branch\n\nLatest: $LATEST_COMMIT_MSG" \
            2>/dev/null || true
        
        # Note: Mako action handling happens via mako config or external script
        # Actions are passed as environment variables to the default action handler
    fi
    
    exit 1
fi

